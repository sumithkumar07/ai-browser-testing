// ENHANCED AI SYSTEM - Zero UI Impact Maximum Backend Utilization
// This system enhances AI responses by automatically utilizing ALL backend services

const { EnhancedAIOrchestrator } = require('./enhanced-ai-orchestrator.js');

class EnhancedAISystem {
  constructor(browserManager) {
    this.manager = browserManager;
    this.orchestrator = null;
    this.isEnabled = true;
    this.responseEnhancer = new AIResponseEnhancer(browserManager);
    this.performancePredictor = new PerformancePredictor(browserManager);
    this.errorPredictor = new ErrorPredictor(browserManager);
    this.contextualActivator = new ContextualServiceActivator(browserManager);
    this.interactionCounter = 0;
  }

  async initialize() {
    try {
      console.log('🚀 Initializing Enhanced AI System - MAXIMUM BACKEND UTILIZATION');
      
      // Initialize the main orchestrator
      this.orchestrator = new EnhancedAIOrchestrator(this.manager);
      await this.orchestrator.initialize();
      
      // Initialize sub-systems
      await this.responseEnhancer.initialize();
      await this.performancePredictor.initialize();
      await this.errorPredictor.initialize();
      await this.contextualActivator.initialize();
      
      console.log('✅ Enhanced AI System initialized - ALL backend services will be automatically utilized');
    } catch (error) {
      console.error('❌ Enhanced AI System initialization failed:', error);
      this.isEnabled = false;
    }
  }

  // 🎯 MAIN ENHANCEMENT METHOD - Called for every AI interaction
  async enhanceAIInteraction(userMessage, originalResponse, context = {}) {
    if (!this.isEnabled) return originalResponse;
    
    this.interactionCounter++;
    const startTime = Date.now();
    
    console.log(`🎼 Enhancing AI interaction #${this.interactionCounter}: "${userMessage.substring(0, 50)}..."`);

    try {
      // PHASE 1: Contextual Service Activation (based on page/domain)
      await this.contextualActivator.activateContextualServices(context);

      // PHASE 2: Multi-Service Orchestration
      const orchestrationResult = await this.orchestrator.orchestrateServices(userMessage, {
        ...context,
        startTime
      });

      // PHASE 3: Response Enhancement
      let enhancedResponse = originalResponse;
      if (orchestrationResult.enhancedResponse) {
        enhancedResponse = originalResponse + orchestrationResult.enhancedResponse;
      }

      // PHASE 4: Add Auto-Generated Insights
      enhancedResponse = await this.addAutoGeneratedInsights(enhancedResponse, orchestrationResult, context);

      // PHASE 5: Add Proactive Feature Discovery
      enhancedResponse = this.addProactiveFeatureDiscovery(enhancedResponse, orchestrationResult, userMessage);

      // PHASE 6: Performance Optimization
      await this.performancePredictor.optimizePerformance();

      const duration = Date.now() - startTime;
      console.log(`✅ AI enhancement completed in ${duration}ms with ${orchestrationResult.activatedServices.length} services`);

      return enhancedResponse;

    } catch (error) {
      console.error('❌ AI enhancement failed:', error);
      return originalResponse; // Fallback to original response
    }
  }

  // 🤖 AUTO-GENERATED INSIGHTS
  async addAutoGeneratedInsights(response, orchestrationResult, context) {
    let enhancedResponse = response;

    try {
      // Add system status insights
      const systemInsights = await this.generateSystemInsights(orchestrationResult);
      if (systemInsights) {
        enhancedResponse += `\n\n## 📊 **System Status:**\n${systemInsights}`;
      }

      // Add learning insights
      const learningInsights = await this.generateLearningInsights(orchestrationResult);
      if (learningInsights) {
        enhancedResponse += `\n\n## 🧠 **Learning Update:**\n${learningInsights}`;
      }

      // Add automation insights
      const automationInsights = await this.generateAutomationInsights(orchestrationResult);
      if (automationInsights) {
        enhancedResponse += `\n\n## ⚡ **Automation Status:**\n${automationInsights}`;
      }

      return enhancedResponse;

    } catch (error) {
      console.error('❌ Auto-generated insights failed:', error);
      return response;
    }
  }

  // 🎪 PROACTIVE FEATURE DISCOVERY
  addProactiveFeatureDiscovery(response, orchestrationResult, userMessage) {
    let enhancedResponse = response;

    try {
      const discoveryInsights = [];

      // Educate about activated services
      if (orchestrationResult.activatedServices.length > 2) {
        discoveryInsights.push(`I automatically activated ${orchestrationResult.activatedServices.length} backend services to provide comprehensive assistance`);
      }

      // Educate about autonomous goals
      if (orchestrationResult.serviceResults.planning?.activeGoals?.length > 0) {
        discoveryInsights.push(`You have ${orchestrationResult.serviceResults.planning.activeGoals.length} autonomous goals actively working in the background`);
      }

      // Educate about background tasks
      if (orchestrationResult.serviceResults.tasks?.taskStats) {
        const stats = orchestrationResult.serviceResults.tasks.taskStats;
        if (stats.running > 0 || stats.pending > 0) {
          discoveryInsights.push(`Background automation: ${stats.running} tasks running, ${stats.pending} queued`);
        }
      }

      // Educate about learning capabilities
      if (orchestrationResult.serviceResults.memory?.learningInsights?.totalOutcomes > 0) {
        const insights = orchestrationResult.serviceResults.memory.learningInsights;
        discoveryInsights.push(`I've analyzed ${insights.totalOutcomes} of your interactions to continuously improve assistance`);
      }

      // Educate about security monitoring
      if (orchestrationResult.serviceResults.security?.securityScan) {
        discoveryInsights.push(`Automatically performed security scan on current site - all your browsing is continuously monitored for safety`);
      }

      if (discoveryInsights.length > 0) {
        enhancedResponse += `\n\n## 🎯 **Behind the Scenes:**\n${discoveryInsights.map(insight => `• ${insight}`).join('\n')}`;
      }

      return enhancedResponse;

    } catch (error) {
      console.error('❌ Proactive feature discovery failed:', error);
      return response;
    }
  }

  // Generate insights from different services
  async generateSystemInsights(orchestrationResult) {
    const insights = [];

    try {
      // Performance insights
      if (orchestrationResult.serviceResults.performance?.performance) {
        const perf = orchestrationResult.serviceResults.performance.performance;
        insights.push(`System running at ${(perf.successRate * 100).toFixed(1)}% efficiency`);
      }

      // Service health insights
      const healthyServices = Object.values(orchestrationResult.serviceResults)
        .filter(result => result.status === 'success').length;
      insights.push(`${healthyServices}/${Object.keys(orchestrationResult.serviceResults).length} backend services operating optimally`);

      return insights.join('\n• ');

    } catch (error) {
      return null;
    }
  }

  async generateLearningInsights(orchestrationResult) {
    try {
      if (orchestrationResult.serviceResults.memory?.learningInsights) {
        const insights = orchestrationResult.serviceResults.memory.learningInsights;
        return `I've learned from ${insights.totalOutcomes || 0} interactions and continuously optimize my responses based on your preferences`;
      }
      return null;
    } catch (error) {
      return null;
    }
  }

  async generateAutomationInsights(orchestrationResult) {
    const insights = [];

    try {
      // Goal automation insights
      if (orchestrationResult.serviceResults.planning?.planningStats) {
        const stats = orchestrationResult.serviceResults.planning.planningStats;
        if (stats.activeGoals > 0) {
          insights.push(`${stats.activeGoals} autonomous goals actively optimizing your experience`);
        }
        if (stats.completedGoals > 0) {
          insights.push(`${stats.completedGoals} goals completed automatically`);
        }
      }

      // Task automation insights
      if (orchestrationResult.proactiveActions?.length > 0) {
        insights.push(`Performed ${orchestrationResult.proactiveActions.length} proactive optimizations`);
      }

      return insights.length > 0 ? insights.join('\n• ') : null;

    } catch (error) {
      return null;
    }
  }
}

// CONTEXTUAL SERVICE ACTIVATOR - Activates services based on website/page context
class ContextualServiceActivator {
  constructor(browserManager) {
    this.manager = browserManager;
    this.contextRules = new Map();
    this.initializeContextRules();
  }

  async initialize() {
    console.log('🎭 Initializing Contextual Service Activator...');
    this.initializeContextRules();
  }

  initializeContextRules() {
    // News/Information sites
    this.contextRules.set('news_sites', {
      domains: ['news.google.com', 'cnn.com', 'bbc.com', 'reuters.com', 'techcrunch.com'],
      keywords: ['news', 'article', 'breaking'],
      services: ['research', 'monitoring', 'memory'],
      actions: ['create_trend_monitoring', 'analyze_credibility', 'store_important_news']
    });

    // Shopping sites
    this.contextRules.set('shopping_sites', {
      domains: ['amazon.com', 'ebay.com', 'shopify.com', 'etsy.com'],
      keywords: ['price', 'buy', 'cart', 'product'],
      services: ['shopping', 'monitoring', 'comparison'],
      actions: ['price_monitoring', 'deal_alerts', 'comparison_analysis']
    });

    // Educational sites
    this.contextRules.set('educational_sites', {
      domains: ['wikipedia.org', 'coursera.org', 'khan academy.org', 'stackoverflow.com'],
      keywords: ['learn', 'tutorial', 'course', 'education'],
      services: ['research', 'memory', 'goals'],
      actions: ['create_learning_goals', 'bookmark_resources', 'track_progress']
    });

    // Business/Professional sites
    this.contextRules.set('business_sites', {
      domains: ['linkedin.com', 'github.com', 'slack.com'],
      keywords: ['work', 'professional', 'career', 'project'],
      services: ['productivity', 'goals', 'automation'],
      actions: ['optimize_workflow', 'track_professional_goals', 'enhance_productivity']
    });

    // Social Media sites
    this.contextRules.set('social_sites', {
      domains: ['twitter.com', 'facebook.com', 'instagram.com', 'reddit.com'],
      keywords: ['social', 'share', 'community'],
      services: ['content_analysis', 'security', 'memory'],
      actions: ['monitor_privacy', 'analyze_trends', 'protect_personal_info']
    });
  }

  async activateContextualServices(context) {
    if (!context.url || context.url === 'about:blank') return;

    try {
      const domain = this.extractDomain(context.url);
      const pageTitle = context.title || '';
      
      for (const [ruleName, rule] of this.contextRules.entries()) {
        if (this.shouldActivateRule(rule, domain, pageTitle, context)) {
          console.log(`🎯 Contextual activation: ${ruleName} for domain ${domain}`);
          await this.executeContextualActions(rule, context);
        }
      }

    } catch (error) {
      console.error('❌ Contextual service activation failed:', error);
    }
  }

  shouldActivateRule(rule, domain, title, context) {
    // Check domain match
    if (rule.domains.some(d => domain.includes(d))) return true;
    
    // Check keyword match in title or URL
    const textToCheck = (title + ' ' + context.url).toLowerCase();
    return rule.keywords.some(keyword => textToCheck.includes(keyword));
  }

  async executeContextualActions(rule, context) {
    try {
      for (const action of rule.actions) {
        switch (action) {
          case 'create_trend_monitoring':
            await this.createTrendMonitoring(context);
            break;
          case 'price_monitoring':
            await this.setupPriceMonitoring(context);
            break;
          case 'create_learning_goals':
            await this.createLearningGoals(context);
            break;
          case 'monitor_privacy':
            await this.monitorPrivacy(context);
            break;
          // Add more contextual actions as needed
        }
      }
    } catch (error) {
      console.error('❌ Contextual action execution failed:', error);
    }
  }

  async createTrendMonitoring(context) {
    if (this.manager.taskScheduler) {
      await this.manager.taskScheduler.scheduleTask('research_monitoring', {
        topic: context.title,
        url: context.url,
        domain: this.extractDomain(context.url)
      }, {
        priority: 3,
        scheduledFor: Date.now() + (24 * 60 * 60 * 1000) // 24 hours
      });
    }
  }

  async setupPriceMonitoring(context) {
    if (this.manager.taskScheduler) {
      await this.manager.taskScheduler.scheduleTask('price_monitoring', {
        product: context.title,
        url: context.url,
        previousPrice: null // Will be detected
      }, {
        priority: 4,
        scheduledFor: Date.now() + (12 * 60 * 60 * 1000) // 12 hours
      });
    }
  }

  async createLearningGoals(context) {
    if (this.manager.autonomousPlanningEngine) {
      await this.manager.autonomousPlanningEngine.createAutonomousGoal({
        title: `Learn: ${context.title}`,
        description: `Systematic learning goal created from educational content`,
        type: 'learning',
        priority: 'medium',
        targetOutcome: 'Complete learning and retain key information',
        successCriteria: ['Review content thoroughly', 'Create summary notes', 'Test understanding'],
        createdBy: 'contextual_activator'
      });
    }
  }

  async monitorPrivacy(context) {
    if (this.manager.advancedSecurity) {
      await this.manager.advancedSecurity.performSecurityScan(context.url, 'privacy_focused');
    }
  }

  extractDomain(url) {
    try {
      return new URL(url).hostname.replace('www.', '');
    } catch {
      return '';
    }
  }
}

// AI RESPONSE ENHANCER - Adds intelligence to every response
class AIResponseEnhancer {
  constructor(manager) {
    this.manager = manager;
    this.memoryService = null;
    this.planningEngine = null;
    this.searchEngine = null;
    this.securityService = null;
  }

  async initialize() {
    this.memoryService = this.manager.agentMemoryService;
    this.planningEngine = this.manager.autonomousPlanningEngine;
    this.searchEngine = this.manager.deepSearchEngine;
    this.securityService = this.manager.advancedSecurity;
  }

  async enhance(originalResponse, userMessage, context) {
    try {
      let enhancedResponse = originalResponse;

      // Add contextual intelligence using AgentMemoryService
      if (this.memoryService) {
        const memoryInsights = await this.addMemoryInsights(userMessage, context);
        if (memoryInsights) {
          enhancedResponse = this.integrateMemoryInsights(enhancedResponse, memoryInsights);
        }
      }

      // Add autonomous planning suggestions
      if (this.planningEngine) {
        const planningInsights = await this.addPlanningInsights(userMessage, context);
        if (planningInsights) {
          enhancedResponse = this.integratePlanningInsights(enhancedResponse, planningInsights);
        }
      }

      return enhancedResponse;

    } catch (error) {
      console.error('❌ Response enhancement failed:', error);
      return originalResponse;
    }
  }

  async addMemoryInsights(userMessage, context) {
    try {
      if (!this.memoryService) return null;

      const memories = await this.memoryService.retrieveMemories('ai_assistant', {
        contentSearch: userMessage.toLowerCase(),
        limit: 3,
        minImportance: 4
      });

      if (memories.success && memories.memories.length > 0) {
        return {
          type: 'memory_insights',
          relevantMemories: memories.memories,
          patterns: this.extractPatterns(memories.memories)
        };
      }

      return null;
    } catch (error) {
      console.error('❌ Memory insights failed:', error);
      return null;
    }
  }

  async addPlanningInsights(userMessage, context) {
    try {
      if (!this.planningEngine) return null;

      const activeGoals = await this.planningEngine.getAllGoals('executing');
      const relevantGoals = activeGoals.filter(goal => 
        goal.title.toLowerCase().includes(userMessage.toLowerCase().split(' ')[0]) ||
        goal.description.toLowerCase().includes(userMessage.toLowerCase().split(' ')[0])
      );

      if (relevantGoals.length > 0) {
        return {
          type: 'planning_insights',
          relevantGoals: relevantGoals.slice(0, 2),
          suggestion: 'I can create additional goals related to this topic'
        };
      }

      return null;
    } catch (error) {
      console.error('❌ Planning insights failed:', error);
      return null;
    }
  }

  integrateMemoryInsights(response, insights) {
    if (!insights.relevantMemories.length) return response;

    const memorySection = `\n\n## 🧠 **Context from Memory:**\n${
      insights.relevantMemories.slice(0, 2).map(memory => {
        const content = typeof memory.content === 'object' ? 
          memory.content.userMessage || 'Previous interaction' : 
          memory.content;
        return `• ${content.substring(0, 120)}...`;
      }).join('\n')
    }`;

    return response + memorySection;
  }

  integratePlanningInsights(response, insights) {
    if (insights.relevantGoals.length > 0) {
      const goalSection = `\n\n## 🎯 **Related Active Goals:**\n${
        insights.relevantGoals.map(goal => 
          `• **${goal.title}** (${goal.progress || 0}% complete)`
        ).join('\n')
      }\n\n💡 ${insights.suggestion}`;
      
      return response + goalSection;
    }
    return response;
  }

  extractPatterns(memories) {
    const topics = memories.map(m => {
      if (typeof m.content === 'object' && m.content.userMessage) {
        return m.content.userMessage.split(' ').slice(0, 3).join(' ');
      }
      return 'general';
    });
    return [...new Set(topics)].slice(0, 3);
  }
}

// PERFORMANCE PREDICTOR - Optimizes system performance
class PerformancePredictor {
  constructor(manager) {
    this.manager = manager;
    this.performanceMonitor = null;
    this.orchestrator = null;
    this.lastOptimization = 0;
    this.optimizationInterval = 5 * 60 * 1000; // 5 minutes
  }

  async initialize() {
    this.performanceMonitor = this.manager.performanceMonitor;
    this.orchestrator = this.manager.unifiedServiceOrchestrator;
    this.startContinuousOptimization();
  }

  startContinuousOptimization() {
    setInterval(async () => {
      await this.optimizePerformance();
    }, this.optimizationInterval);
  }

  async optimizePerformance() {
    try {
      const now = Date.now();
      if (now - this.lastOptimization < this.optimizationInterval) return;

      if (this.orchestrator) {
        const health = this.orchestrator.getSystemHealth();
        const metrics = this.orchestrator.getSystemMetrics(1)[0];

        if (health.overall < 0.9 || (metrics && metrics.averageResponseTime > 200)) {
          await this.performPredictiveOptimization(health, metrics);
        }
      }

      this.lastOptimization = now;
    } catch (error) {
      console.error('❌ Performance optimization failed:', error);
    }
  }

  async performPredictiveOptimization(health, metrics) {
    console.log('⚡ Performing predictive performance optimization...');

    // Optimize based on current performance
    if (metrics && metrics.averageResponseTime > 500) {
      this.optimizeResponseTime();
    }

    if (health.overall < 0.8) {
      await this.optimizeSystemHealth(health);
    }

    // Predictive memory cleanup
    if (global.gc && process.memoryUsage().heapUsed > 200 * 1024 * 1024) {
      global.gc();
      console.log('🧹 Predictive memory cleanup performed');
    }
  }

  optimizeResponseTime() {
    console.log('⚡ Optimizing AI response processing...');
    // Implementation would optimize AI response processing
  }

  async optimizeSystemHealth(health) {
    const unhealthyServices = health.services.filter(s => s.status !== 'healthy');
    
    for (const service of unhealthyServices) {
      console.log(`🔧 Attempting to optimize ${service.name}...`);
      // Implementation would restart or optimize specific services
    }
  }
}

// ERROR PREDICTOR - Prevents errors before they happen
class ErrorPredictor {
  constructor(manager) {
    this.manager = manager;
    this.memoryService = null;
    this.errorPatterns = new Map();
    this.recentErrors = [];
    this.maxErrorHistory = 100;
  }

  async initialize() {
    this.memoryService = this.manager.agentMemoryService;
    this.loadErrorPatterns();
  }

  loadErrorPatterns() {
    // Initialize common error patterns
    this.errorPatterns.set('api_call', { successes: 80, failures: 20 });
    this.errorPatterns.set('file_operation', { successes: 95, failures: 5 });
    this.errorPatterns.set('network_request', { successes: 85, failures: 15 });
    this.errorPatterns.set('database_operation', { successes: 98, failures: 2 });
  }

  async predict(operation, context) {
    try {
      const riskScore = await this.calculateRiskScore(operation, context);
      
      if (riskScore > 0.7) {
        console.log(`⚠️ High error risk detected for operation: ${operation}`);
        return {
          shouldProceed: false,
          reason: 'High error probability detected',
          recommendation: 'Consider alternative approach',
          riskScore: riskScore
        };
      }

      return { shouldProceed: true, riskScore: riskScore };

    } catch (error) {
      console.error('❌ Error prediction failed:', error);
      return { shouldProceed: true }; // Fail open
    }
  }

  async calculateRiskScore(operation, context) {
    let riskScore = 0.0;

    // Check historical error patterns
    const historicalRisk = this.checkHistoricalPatterns(operation, context);
    riskScore += historicalRisk * 0.4;

    // Check current system health
    const systemHealthRisk = this.checkSystemHealth();
    riskScore += systemHealthRisk * 0.3;

    // Check context-specific risks
    const contextRisk = this.checkContextRisks(operation, context);
    riskScore += contextRisk * 0.3;

    return Math.min(1.0, riskScore);
  }

  checkHistoricalPatterns(operation, context) {
    const pattern = this.errorPatterns.get(operation);
    if (!pattern) return 0.1;

    const totalAttempts = pattern.successes + pattern.failures;
    if (totalAttempts === 0) return 0.1;

    return pattern.failures / totalAttempts;
  }

  checkSystemHealth() {
    if (this.manager.unifiedServiceOrchestrator) {
      const health = this.manager.unifiedServiceOrchestrator.getSystemHealth();
      return 1.0 - health.overall;
    }
    return 0.2;
  }

  checkContextRisks(operation, context) {
    let risk = 0.0;

    if (context.url && context.url.includes('http://')) {
      risk += 0.3;
    }

    const memoryUsage = process.memoryUsage();
    if (memoryUsage.heapUsed > 400 * 1024 * 1024) {
      risk += 0.2;
    }

    return Math.min(1.0, risk);
  }
}

module.exports = { EnhancedAISystem };